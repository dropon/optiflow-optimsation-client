/*
Route Optimization OptiFlow

With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.

API version: 1.10
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the TaskGroup type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TaskGroup{}

// TaskGroup A group of tasks identified by a category. Tasks belonging to the same task group must be planned on the same route, or consecutively if they are on the same route, depending on the constraints defined in the task group.
type TaskGroup struct {
	// The category that defines which tasks belong to this task group. The constraint will be ignored when no task belongs to this category.
	TaskCategory string `json:"taskCategory" validate:"regexp=^[a-zA-Z0-9_-]{1,36}$"`
	Constraint TaskGroupConstraint `json:"constraint"`
}

type _TaskGroup TaskGroup

// NewTaskGroup instantiates a new TaskGroup object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTaskGroup(taskCategory string, constraint TaskGroupConstraint) *TaskGroup {
	this := TaskGroup{}
	this.TaskCategory = taskCategory
	this.Constraint = constraint
	return &this
}

// NewTaskGroupWithDefaults instantiates a new TaskGroup object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTaskGroupWithDefaults() *TaskGroup {
	this := TaskGroup{}
	return &this
}

// GetTaskCategory returns the TaskCategory field value
func (o *TaskGroup) GetTaskCategory() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.TaskCategory
}

// GetTaskCategoryOk returns a tuple with the TaskCategory field value
// and a boolean to check if the value has been set.
func (o *TaskGroup) GetTaskCategoryOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TaskCategory, true
}

// SetTaskCategory sets field value
func (o *TaskGroup) SetTaskCategory(v string) {
	o.TaskCategory = v
}

// GetConstraint returns the Constraint field value
func (o *TaskGroup) GetConstraint() TaskGroupConstraint {
	if o == nil {
		var ret TaskGroupConstraint
		return ret
	}

	return o.Constraint
}

// GetConstraintOk returns a tuple with the Constraint field value
// and a boolean to check if the value has been set.
func (o *TaskGroup) GetConstraintOk() (*TaskGroupConstraint, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Constraint, true
}

// SetConstraint sets field value
func (o *TaskGroup) SetConstraint(v TaskGroupConstraint) {
	o.Constraint = v
}

func (o TaskGroup) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TaskGroup) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["taskCategory"] = o.TaskCategory
	toSerialize["constraint"] = o.Constraint
	return toSerialize, nil
}

func (o *TaskGroup) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"taskCategory",
		"constraint",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varTaskGroup := _TaskGroup{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varTaskGroup)

	if err != nil {
		return err
	}

	*o = TaskGroup(varTaskGroup)

	return err
}

type NullableTaskGroup struct {
	value *TaskGroup
	isSet bool
}

func (v NullableTaskGroup) Get() *TaskGroup {
	return v.value
}

func (v *NullableTaskGroup) Set(val *TaskGroup) {
	v.value = val
	v.isSet = true
}

func (v NullableTaskGroup) IsSet() bool {
	return v.isSet
}

func (v *NullableTaskGroup) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTaskGroup(val *TaskGroup) *NullableTaskGroup {
	return &NullableTaskGroup{value: val, isSet: true}
}

func (v NullableTaskGroup) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTaskGroup) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


