/*
Route Optimization OptiFlow

With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.

API version: 1.28
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the RepositioningEffortCost type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &RepositioningEffortCost{}

// RepositioningEffortCost Specifies an increased cost per effort if the route's repositioning effort goes above a threshold. When two orders are loaded into the same compartment and delivered in the reverse order, we refer to them as a non-last-in-first-out (non-LIFO) pair. Any non-LIFO pair of orders requires repositioning in the vehicle, as the last picked-up order obstructs the first order that needs to be delivered. The effort involved in this repositioning is the minimum effort required for the two orders. The total repositioning effort for the route is the sum of the repositioning efforts for all non-LIFO pairs of orders.
type RepositioningEffortCost struct {
	// The threshold for the repositioning effort from which the cost per effort applies.
	Threshold int32 `json:"threshold"`
	// Specifies the extra cost for every unit of effort above the threshold. If the threshold of multiple repositioning effort costs is exceeded, the extra costs per effort are added.
	ExtraPerEffort float64 `json:"extraPerEffort"`
}

type _RepositioningEffortCost RepositioningEffortCost

// NewRepositioningEffortCost instantiates a new RepositioningEffortCost object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRepositioningEffortCost(threshold int32, extraPerEffort float64) *RepositioningEffortCost {
	this := RepositioningEffortCost{}
	this.Threshold = threshold
	this.ExtraPerEffort = extraPerEffort
	return &this
}

// NewRepositioningEffortCostWithDefaults instantiates a new RepositioningEffortCost object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRepositioningEffortCostWithDefaults() *RepositioningEffortCost {
	this := RepositioningEffortCost{}
	return &this
}

// GetThreshold returns the Threshold field value
func (o *RepositioningEffortCost) GetThreshold() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.Threshold
}

// GetThresholdOk returns a tuple with the Threshold field value
// and a boolean to check if the value has been set.
func (o *RepositioningEffortCost) GetThresholdOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Threshold, true
}

// SetThreshold sets field value
func (o *RepositioningEffortCost) SetThreshold(v int32) {
	o.Threshold = v
}

// GetExtraPerEffort returns the ExtraPerEffort field value
func (o *RepositioningEffortCost) GetExtraPerEffort() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.ExtraPerEffort
}

// GetExtraPerEffortOk returns a tuple with the ExtraPerEffort field value
// and a boolean to check if the value has been set.
func (o *RepositioningEffortCost) GetExtraPerEffortOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ExtraPerEffort, true
}

// SetExtraPerEffort sets field value
func (o *RepositioningEffortCost) SetExtraPerEffort(v float64) {
	o.ExtraPerEffort = v
}

func (o RepositioningEffortCost) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o RepositioningEffortCost) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["threshold"] = o.Threshold
	toSerialize["extraPerEffort"] = o.ExtraPerEffort
	return toSerialize, nil
}

func (o *RepositioningEffortCost) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"threshold",
		"extraPerEffort",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRepositioningEffortCost := _RepositioningEffortCost{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRepositioningEffortCost)

	if err != nil {
		return err
	}

	*o = RepositioningEffortCost(varRepositioningEffortCost)

	return err
}

type NullableRepositioningEffortCost struct {
	value *RepositioningEffortCost
	isSet bool
}

func (v NullableRepositioningEffortCost) Get() *RepositioningEffortCost {
	return v.value
}

func (v *NullableRepositioningEffortCost) Set(val *RepositioningEffortCost) {
	v.value = val
	v.isSet = true
}

func (v NullableRepositioningEffortCost) IsSet() bool {
	return v.isSet
}

func (v *NullableRepositioningEffortCost) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRepositioningEffortCost(val *RepositioningEffortCost) *NullableRepositioningEffortCost {
	return &NullableRepositioningEffortCost{value: val, isSet: true}
}

func (v NullableRepositioningEffortCost) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRepositioningEffortCost) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


