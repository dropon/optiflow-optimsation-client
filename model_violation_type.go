/*
Route Optimization

With the Route Optimization service you can schedule and optimize the routes of your fleet.

API version: 1.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow

import (
	"encoding/json"
	"fmt"
)

// ViolationType Specifies the type of violation.   * `PLANNING_HORIZON` - The planning horizon is violated.   * `DRIVER_AVAILABILITY` - The availabilities of the driver are violated.   * `ROUTE_START_INTERVAL` - The route start interval is violated.   * `OPENING_INTERVAL` - The opening intervals of the location are violated.   * `VEHICLE_CAPACITY` - At least one of the vehicle capacities is violated.   * `VEHICLE_EQUIPMENT` - Not all vehicle equipment for the currently loaded transports is available.   * `MAXIMUM_TRAVEL_TIME_OF_DRIVER` - Indicates a violation of the maximum allowed travel time of driver as specified at the driver or by the drivers' working hours restriction.   * `MAXIMUM_DRIVING_TIME_OF_DRIVER` - Indicates a violation of the maximum allowed driving time of driver as specified at the driver or by the drivers' working hours restriction.  * `MAXIMUM_DISTANCE` - Indicates a violation of the maximum allowed driving distance as specified at the vehicle.   * `MAXIMUM_NUMBER_OF_CUSTOMER_STOPS` - Indicates a violation of the maximum allowed number of customer stops as specified at the vehicle.   * `REST_POSITION` - Indicates that a daily rest is not at the end of a trip. In this case the expected position for a daily rest is at the end of a trip.   * `STOP_POSITION_IN_TRIP` - Indicates a violation of the stop position in the trip.   * `TRIP_SECTION` - Indicates a violation of the trip section numbers of a customer stop.   * `MIXED_LOADING_PROHIBITION` - Indicates a violation of the mixed loading prohibitions.
type ViolationType string

// List of ViolationType
const (
	PLANNING_HORIZON ViolationType = "PLANNING_HORIZON"
	DRIVER_AVAILABILITY ViolationType = "DRIVER_AVAILABILITY"
	ROUTE_START_INTERVAL ViolationType = "ROUTE_START_INTERVAL"
	OPENING_INTERVAL ViolationType = "OPENING_INTERVAL"
	VEHICLE_CAPACITY ViolationType = "VEHICLE_CAPACITY"
	VEHICLE_EQUIPMENT ViolationType = "VEHICLE_EQUIPMENT"
	MAXIMUM_TRAVEL_TIME_OF_DRIVER ViolationType = "MAXIMUM_TRAVEL_TIME_OF_DRIVER"
	MAXIMUM_DRIVING_TIME_OF_DRIVER ViolationType = "MAXIMUM_DRIVING_TIME_OF_DRIVER"
	MAXIMUM_DISTANCE ViolationType = "MAXIMUM_DISTANCE"
	MAXIMUM_NUMBER_OF_CUSTOMER_STOPS ViolationType = "MAXIMUM_NUMBER_OF_CUSTOMER_STOPS"
	REST_POSITION ViolationType = "REST_POSITION"
	STOP_POSITION_IN_TRIP ViolationType = "STOP_POSITION_IN_TRIP"
	TRIP_SECTION ViolationType = "TRIP_SECTION"
	MIXED_LOADING_PROHIBITION ViolationType = "MIXED_LOADING_PROHIBITION"
)

// All allowed values of ViolationType enum
var AllowedViolationTypeEnumValues = []ViolationType{
	"PLANNING_HORIZON",
	"DRIVER_AVAILABILITY",
	"ROUTE_START_INTERVAL",
	"OPENING_INTERVAL",
	"VEHICLE_CAPACITY",
	"VEHICLE_EQUIPMENT",
	"MAXIMUM_TRAVEL_TIME_OF_DRIVER",
	"MAXIMUM_DRIVING_TIME_OF_DRIVER",
	"MAXIMUM_DISTANCE",
	"MAXIMUM_NUMBER_OF_CUSTOMER_STOPS",
	"REST_POSITION",
	"STOP_POSITION_IN_TRIP",
	"TRIP_SECTION",
	"MIXED_LOADING_PROHIBITION",
}

func (v *ViolationType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ViolationType(value)
	for _, existing := range AllowedViolationTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ViolationType", value)
}

// NewViolationTypeFromValue returns a pointer to a valid ViolationType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewViolationTypeFromValue(v string) (*ViolationType, error) {
	ev := ViolationType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ViolationType: valid values are %v", v, AllowedViolationTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ViolationType) IsValid() bool {
	for _, existing := range AllowedViolationTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ViolationType value
func (v ViolationType) Ptr() *ViolationType {
	return &v
}

type NullableViolationType struct {
	value *ViolationType
	isSet bool
}

func (v NullableViolationType) Get() *ViolationType {
	return v.value
}

func (v *NullableViolationType) Set(val *ViolationType) {
	v.value = val
	v.isSet = true
}

func (v NullableViolationType) IsSet() bool {
	return v.isSet
}

func (v *NullableViolationType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableViolationType(val *ViolationType) *NullableViolationType {
	return &NullableViolationType{value: val, isSet: true}
}

func (v NullableViolationType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableViolationType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

