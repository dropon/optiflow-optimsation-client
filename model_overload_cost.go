/*
Route Optimization OptiFlow

With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.

API version: 1.27
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the OverloadCost type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &OverloadCost{}

// OverloadCost Defines an extra cost that is applied whenever an order is loaded onto the vehicle and the vehicle's load exceeds the specified threshold.
type OverloadCost struct {
	// Indicates the dimension of the load, to which the threshold applies.
	Dimension string `json:"dimension" validate:"regexp=^[a-zA-Z0-9_-]{1,36}$"`
	// The threshold for the specified load dimension.  When an order is loaded, only the part of that order which contributes to exceeding the threshold is considered for the extra cost.
	Threshold float64 `json:"threshold"`
	// Specifies the extra cost per unit when loading an order which exceeds the threshold.
	ExtraPerUnit float64 `json:"extraPerUnit"`
}

type _OverloadCost OverloadCost

// NewOverloadCost instantiates a new OverloadCost object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewOverloadCost(dimension string, threshold float64, extraPerUnit float64) *OverloadCost {
	this := OverloadCost{}
	this.Dimension = dimension
	this.Threshold = threshold
	this.ExtraPerUnit = extraPerUnit
	return &this
}

// NewOverloadCostWithDefaults instantiates a new OverloadCost object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewOverloadCostWithDefaults() *OverloadCost {
	this := OverloadCost{}
	return &this
}

// GetDimension returns the Dimension field value
func (o *OverloadCost) GetDimension() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Dimension
}

// GetDimensionOk returns a tuple with the Dimension field value
// and a boolean to check if the value has been set.
func (o *OverloadCost) GetDimensionOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Dimension, true
}

// SetDimension sets field value
func (o *OverloadCost) SetDimension(v string) {
	o.Dimension = v
}

// GetThreshold returns the Threshold field value
func (o *OverloadCost) GetThreshold() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.Threshold
}

// GetThresholdOk returns a tuple with the Threshold field value
// and a boolean to check if the value has been set.
func (o *OverloadCost) GetThresholdOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Threshold, true
}

// SetThreshold sets field value
func (o *OverloadCost) SetThreshold(v float64) {
	o.Threshold = v
}

// GetExtraPerUnit returns the ExtraPerUnit field value
func (o *OverloadCost) GetExtraPerUnit() float64 {
	if o == nil {
		var ret float64
		return ret
	}

	return o.ExtraPerUnit
}

// GetExtraPerUnitOk returns a tuple with the ExtraPerUnit field value
// and a boolean to check if the value has been set.
func (o *OverloadCost) GetExtraPerUnitOk() (*float64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ExtraPerUnit, true
}

// SetExtraPerUnit sets field value
func (o *OverloadCost) SetExtraPerUnit(v float64) {
	o.ExtraPerUnit = v
}

func (o OverloadCost) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o OverloadCost) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["dimension"] = o.Dimension
	toSerialize["threshold"] = o.Threshold
	toSerialize["extraPerUnit"] = o.ExtraPerUnit
	return toSerialize, nil
}

func (o *OverloadCost) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"dimension",
		"threshold",
		"extraPerUnit",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varOverloadCost := _OverloadCost{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varOverloadCost)

	if err != nil {
		return err
	}

	*o = OverloadCost(varOverloadCost)

	return err
}

type NullableOverloadCost struct {
	value *OverloadCost
	isSet bool
}

func (v NullableOverloadCost) Get() *OverloadCost {
	return v.value
}

func (v *NullableOverloadCost) Set(val *OverloadCost) {
	v.value = val
	v.isSet = true
}

func (v NullableOverloadCost) IsSet() bool {
	return v.isSet
}

func (v *NullableOverloadCost) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOverloadCost(val *OverloadCost) *NullableOverloadCost {
	return &NullableOverloadCost{value: val, isSet: true}
}

func (v NullableOverloadCost) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOverloadCost) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


