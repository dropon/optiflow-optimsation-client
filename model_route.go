/*
Route Optimization

With the Route Optimization service you can schedule and optimize the routes of your fleet.

API version: 1.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Route type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Route{}

// Route A route contains a sequence of stops. It specifies where and in which order goods are to be picked up or delivered. Each stop can be assigned to a trip. A route is subdivided into trips. Each route has at least one trip and a trip consists of at least two stops. At the beginning and end of each trip the vehicle does not carry any load. A trip starts at the vehicle start location or at a depot location, and ends at the vehicle end location or at a depot location.   See [here](./concepts/routes-and-trips) for more information.
type Route struct {
	// The ID of the vehicle that is assigned to this route. A vehicle can be assigned to one route at most.
	VehicleId string `json:"vehicleId" validate:"regexp=.*[^ ].*"`
	// A sequence of stops along this route. Each stop is at a specific location, either a customer location or a depot location. At a customer location, transports are scheduled in order of their type: deliveries before pickups. The sequence of deliveries and pickups is always sorted by Last In - First Out (LIFO). At a depot location a stop groups either deliveries or pickups.  See [here](./concepts/locations-transports-and-stops) for more information.
	Stops []Stop `json:"stops"`
	// Returns a summary of all events and all reports that belong to this route, including the start time and the end time of the route.
	Report RouteReport `json:"report"`
}

type _Route Route

// NewRoute instantiates a new Route object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRoute(vehicleId string, stops []Stop, report RouteReport) *Route {
	this := Route{}
	this.VehicleId = vehicleId
	this.Stops = stops
	this.Report = report
	return &this
}

// NewRouteWithDefaults instantiates a new Route object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRouteWithDefaults() *Route {
	this := Route{}
	return &this
}

// GetVehicleId returns the VehicleId field value
func (o *Route) GetVehicleId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.VehicleId
}

// GetVehicleIdOk returns a tuple with the VehicleId field value
// and a boolean to check if the value has been set.
func (o *Route) GetVehicleIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.VehicleId, true
}

// SetVehicleId sets field value
func (o *Route) SetVehicleId(v string) {
	o.VehicleId = v
}

// GetStops returns the Stops field value
func (o *Route) GetStops() []Stop {
	if o == nil {
		var ret []Stop
		return ret
	}

	return o.Stops
}

// GetStopsOk returns a tuple with the Stops field value
// and a boolean to check if the value has been set.
func (o *Route) GetStopsOk() ([]Stop, bool) {
	if o == nil {
		return nil, false
	}
	return o.Stops, true
}

// SetStops sets field value
func (o *Route) SetStops(v []Stop) {
	o.Stops = v
}

// GetReport returns the Report field value
func (o *Route) GetReport() RouteReport {
	if o == nil {
		var ret RouteReport
		return ret
	}

	return o.Report
}

// GetReportOk returns a tuple with the Report field value
// and a boolean to check if the value has been set.
func (o *Route) GetReportOk() (*RouteReport, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Report, true
}

// SetReport sets field value
func (o *Route) SetReport(v RouteReport) {
	o.Report = v
}

func (o Route) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Route) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["vehicleId"] = o.VehicleId
	toSerialize["stops"] = o.Stops
	toSerialize["report"] = o.Report
	return toSerialize, nil
}

func (o *Route) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"vehicleId",
		"stops",
		"report",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRoute := _Route{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRoute)

	if err != nil {
		return err
	}

	*o = Route(varRoute)

	return err
}

type NullableRoute struct {
	value *Route
	isSet bool
}

func (v NullableRoute) Get() *Route {
	return v.value
}

func (v *NullableRoute) Set(val *Route) {
	v.value = val
	v.isSet = true
}

func (v NullableRoute) IsSet() bool {
	return v.isSet
}

func (v *NullableRoute) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRoute(val *Route) *NullableRoute {
	return &NullableRoute{value: val, isSet: true}
}

func (v NullableRoute) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRoute) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


