/*
Route Optimization OptiFlow

With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.

API version: 1.29
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// TrafficMode Defines the traffic situation that should be considered when calculating routes. * `CONSTANT` - Describes a situation where travel times stay the same, no matter the departure time.  In this scenario, traffic conditions are assumed to be steady, unaffected by rush hours, events, or other temporary changes in congestion. * `AVERAGE` - Describes a situation where travel times fluctuate, depending on the departure time at a stop. In this scenario, a typical traffic situation for that time of day and day of week will be considered such as the rush-hour on Monday morning or light traffic on Saturday evening. This traffic situation is only supported in Australia (AU), Belgium (BE), Canada (CA), Switzerland (CH), Czechia (CZ), Germany (DE), Spain (ES), France (FR), United Kingdom (GB), Italy (IT), Liechtenstein (LI), Luxembourg (LU), The Netherlands (NL), Vatican City (VA), Andorra (AD), Austria (AT), Monaco (MC), San Marino (SM) and The United States (US) and for the routing profiles `EUR_VAN`, `EUR_TRUCK_11_99T`, `EUR_TRUCK_40T`, `AUS_LCV_LIGHT_COMMERCIAL`, `AUS_MR_MEDIUM_RIGID`, `AUS_HR_HEAVY_RIGID`, `USA_8_SEMITRAILER_5AXLE`, `USA_5_DELIVERY` and `USA_1_PICKUP`. The spherical distance between any two locations should be at most 650 kilometers when using the `AVERAGE` traffic situation. Moreover, the planning horizon for this combination of routing profile and traffic mode should be at most 2 days. The planning horizon is the difference between the maximum of the latest end time and the minimum of the earliest start time of the vehicles using this combination.
type TrafficMode string

// List of TrafficMode
const (
	CONSTANT TrafficMode = "CONSTANT"
	AVERAGE TrafficMode = "AVERAGE"
)

// All allowed values of TrafficMode enum
var AllowedTrafficModeEnumValues = []TrafficMode{
	"CONSTANT",
	"AVERAGE",
}

func (v *TrafficMode) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := TrafficMode(value)
	for _, existing := range AllowedTrafficModeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid TrafficMode", value)
}

// NewTrafficModeFromValue returns a pointer to a valid TrafficMode
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewTrafficModeFromValue(v string) (*TrafficMode, error) {
	ev := TrafficMode(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for TrafficMode: valid values are %v", v, AllowedTrafficModeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v TrafficMode) IsValid() bool {
	for _, existing := range AllowedTrafficModeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TrafficMode value
func (v TrafficMode) Ptr() *TrafficMode {
	return &v
}

type NullableTrafficMode struct {
	value *TrafficMode
	isSet bool
}

func (v NullableTrafficMode) Get() *TrafficMode {
	return v.value
}

func (v *NullableTrafficMode) Set(val *TrafficMode) {
	v.value = val
	v.isSet = true
}

func (v NullableTrafficMode) IsSet() bool {
	return v.isSet
}

func (v *NullableTrafficMode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTrafficMode(val *TrafficMode) *NullableTrafficMode {
	return &NullableTrafficMode{value: val, isSet: true}
}

func (v NullableTrafficMode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTrafficMode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

