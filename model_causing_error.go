/*
Route Optimization

With the Route Optimization service you can schedule and optimize the routes of your fleet.

API version: 1.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the CausingError type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CausingError{}

// CausingError struct for CausingError
type CausingError struct {
	// A human readable message that describes the error.
	Description string `json:"description"`
	// A constant string that can be used to identify this error class programmatically. An errorCode can have **details** to provide information in additional properties which are described with the code they apply to. They are of type string unless otherwise specified. Note that additional errorCodes as well as the **details** of existing errorCodes may be added at any time. Furthermore, the **description** may change at any time.  **Error codes for** `GENERAL_VALIDATION_ERROR` * `GENERAL_INVALID_VALUE` - A parameter is set to an invalid value.   * `value` - The invalid value. * `GENERAL_UNRECOGNIZED_PARAMETER` - A parameter is unknown. * `GENERAL_MISSING_PARAMETER` - A required parameter is missing. * `GENERAL_INVALID_INTERVAL` - A time interval is invalid, i.e. start is greater than end. * `GENERAL_MINIMUM_LENGTH_VIOLATED` - The minimum length is violated.   * `minimumLength` - The minimum length (integer). * `GENERAL_MAXIMUM_LENGTH_VIOLATED` - The maximum length is violated.   * `maximumLength` - The maximum length (integer). * `GENERAL_DUPLICATE_ID` - Two or more objects of the same type have the same ID.   * `value` - The duplicated value.   * `indexes` - The list indexes of the objects with the same ID. * `GENERAL_MINIMUM_VALUE_VIOLATED` - The minimum value restriction is violated.   * `minimumValue` - The minimum value (integer or double). * `GENERAL_MAXIMUM_VALUE_VIOLATED` - The maximum value restriction is violated.   * `maximumValue` - The maximum value (integer or double). * `GENERAL_DUPLICATE_PARAMETER` - A parameter is duplicated. * `ROUTEOPTIMIZATION_EMPTY_ID` - The ID is empty or contains only whitespace. * `ROUTEOPTIMIZATION_LOCATION_CANNOT_BE_MATCHED` - The location cannot be matched to a street and no airline distance fallback is possible. * `ROUTEOPTIMIZATION_DUPLICATE_TRIP_ID` - Two or more trips have the same trip ID.   * `duplicatedTripId` - The duplicated trip ID.   * `routeIndexes` - The list indexes of the routes with the same trip ID. * `ROUTEOPTIMIZATION_DUPLICATE_TRANSPORT` - The transport with ID '' is picked up and/or delivered multiple times.   * `transportId` - The duplicated transport ID. * `ROUTEOPTIMIZATION_SINGLE_TRIP_PER_ROUTE_VIOLATED` - There is more than one trip in the given route although the restriction 'singleTripPerRoute' is activated. * `ROUTEOPTIMIZATION_SINGLE_DEPOT_PER_ROUTE_VIOLATED` - There is more than one depot in the given route although the restriction 'singleDepotPerRoute' is activated. * `ROUTEOPTIMIZATION_ILLEGAL_EMPTY_STOP` - Empty stops without any pickup or delivery are only allowed for the vehicle start/end location or for trip starts/ends at depots. * `ROUTEOPTIMIZATION_DELIVERY_EXECUTED_BEFORE_PICKUP` - Delivery of transport with ID '' is executed before the corresponding pickup.   * `transportId` - The transport ID. * `ROUTEOPTIMIZATION_NO_TRANSPORT_IN_ROUTE` - There is no transport in this route. Please add a transport or remove the whole route. * `ROUTEOPTIMIZATION_DELIVERY_MISSING_IN_ROUTE` - Delivery of transport with ID '' is missing in one of the trips in the given route. Pickup and delivery of a transport need to be in the same trip.   * `transportId` - The transport ID. * `ROUTEOPTIMIZATION_PICKUP_MISSING_IN_ROUTE` - Pickup of transport with ID '' is missing in one of the trips in the given route. Pickup and delivery of a transport need to be in the same trip.   * `transportId` - The transport ID. * `ROUTEOPTIMIZATION_PICKUP_EQUAL_TO_DELIVERY_LOCATION` - Pickup and delivery of transport with ID '' are at the same location. Pickup and delivery of a transport need to be at different locations.   * `transportId` - The transport ID.   * `locationId` - The location ID of the transport pickup and delivery. * `ROUTEOPTIMIZATION_TRIP_STRUCTURE_VIOLATED` - Trip structure violated. * `ROUTEOPTIMIZATION_INVALID_OR_INCONSISTENT_TRIP_ID` - Trip ID is invalid or not all stops of a trip have the same ID. * `ROUTEOPTIMIZATION_NO_TIME_INTERVAL` - The planning horizon is required if there is no other time interval given in the plan. * `ROUTEOPTIMIZATION_CONTIGUOUS_DRIVER_AVAILABILITIES` - The driver availability given in the parameter field must end at least two seconds before the driver availabilty with list index  starts or the contiguous intervals have to be merged.   * `contiguousAvailabilityIndex` - The list index of the driver availability where the start must have a gap of more than one second to the end of the availability given in the parameter field. * `ROUTEOPTIMIZATION_PICKUP_MISSING_IN_LOCATIONS` - The locations list does not contain the pickup location with ID ''.   * `locationId` - The location ID. * `ROUTEOPTIMIZATION_DELIVERY_MISSING_IN_LOCATIONS` - The locations list does not contain the delivery location with ID ''.   * `locationId` - The location ID. * `ROUTEOPTIMIZATION_UNKNOWN_VEHICLE_ID` - A vehicle with ID '' does not exist in the vehicles list.   * `vehicleId` - The vehicle ID. * `ROUTEOPTIMIZATION_VEHICLE_REFERENCED_BY_MULTIPLE_DRIVERS` - A vehicle can only be referenced by one driver. Vehicle with ID '' is referenced by multiple drivers.   * `vehicleId` - The vehicle ID.   * `driverIndexes` - The indexes of the drivers with the same vehicle ID. * `ROUTEOPTIMIZATION_VEHICLE_REFERENCED_BY_MULTIPLE_ROUTES` - A vehicle can only be referenced by one route. Vehicle with ID '' is referenced by multiple routes.   * `vehicleId` - The vehicle ID.   * `routeIndexes` - The indexes of the routes with the same vehicle ID. * `ROUTEOPTIMIZATION_VEHICLE_START_LOCATION_MISSING_IN_ROUTE` - Vehicle start location must be the first stop of the vehicle route.   * `routeIndex` - The list index of the route with missing start location.   * `expectedLocationIdOfFirstStop` - The expected location ID of the first stop of the route which is the given vehicle start location.   * `actualLocationIdOfFirstStop` - The actual location ID of the first stop of the route. * `ROUTEOPTIMIZATION_VEHICLE_END_LOCATION_MISSING_IN_ROUTE` - Vehicle end location must be the last stop of the vehicle route.   * `routeIndex` - The list index of the route with missing end location.   * `expectedLocationIdOfLastStop` - The expected location ID of the last stop of the route which is the given vehicle end location.   * `actualLocationIdOfLastStop` - The actual location ID of the last stop of the route. * `ROUTEOPTIMIZATION_INCONSISTENT_NUMBER_OF_QUANTITIES_AND_CAPACITIES` - The list of the capacities of all vehicles and the list of the quantities of all transports must have the same length. The reference list is given in the parameter field.   * `expectedLength` - The expected length of the list.   * `vehicleIndexes` - The list indexes of the vehicles with the wrong number of capacities.   * `transportIndexes` - The list indexes of the transports with the wrong number of quantities. * `ROUTEOPTIMIZATION_UNREFERENCED_LOCATIONS` - Locations with IDs '' are not referenced or used anywhere. These and all other unreferenced locations must be left out.   * `locationIds` - The IDs of some unreferenced locations. * `ROUTEOPTIMIZATION_UNKNOWN_LOCATION_ID` - A location with ID '' does not exist in the locations list.   * `locationId` - The location ID. * `ROUTEOPTIMIZATION_UNKNOWN_TRANSPORT_ID` - A transport with ID '' does not exist in the transports list.   * `transportId` - The transport ID. * `ROUTEOPTIMIZATION_LOCATIONS_TOO_FAR_AWAY` - Locations or their road access coordinates are too far away from each other when using vehicle profile ''. All locations and road access coordinates have to be inside a rectangle with edges of at most '' km length.   * `profile` - The profile for which the locations are too far away from each other.  * `distance` - The maximum allowed distance in km. * `ROUTEOPTIMIZATION_PICKUP_AT_UNEXPECTED_LOCATION` - Transport with ID '' should not be picked up at this location.   * `transportId` - The ID of the transport which is picked up at an unexpected location.   * `expectedPickupLocationId` - The location ID where transport should be picked up.   * `actualPickupLocationId` - The location ID of the stop where transport is actually picked up. * `ROUTEOPTIMIZATION_DELIVERY_AT_UNEXPECTED_LOCATION` - Transport with ID '' should not be delivered at this location.   * `transportId` - The ID of the transport which is delivered at an unexpected location.   * `expectedDeliveryLocationId` - The location ID where transport should be delivered.   * `actualDeliveryLocationId` - The location ID of the stop where transport is actually delivered. * `ROUTEOPTIMIZATION_ILLEGAL_SPLITTED_STOP` - Subsequent stops at the same location are only allowed if they are in different trips. The given stops must be merged to one stop.   * `stopIndexes` - The list indexes of the stops which should be merged. * `ROUTEOPTIMIZATION_INVALID_LOADING_SEQUENCE` - A location in a route is left with unfinished tasks: Either a location is left although there is still load FOR it on the vehicle or a location is visited again although there are still pickups FROM it on the vehicle.   * `locationId` - The location ID with unfinished tasks. * `ROUTEOPTIMIZATION_STOP_SERVICE_TIME_TOO_LONG` - The service time of the stop exceeds the travel time between daily rests or the working time between breaks defined by the rules for the driver. * `ROUTEOPTIMIZATION_PLANNING_HORIZON_TOO_LONG` - Planning horizon must not be longer than 14 days. * `ROUTEOPTIMIZATION_PLAN_IN_OPTIMIZATION` - Plan with ID '' is already in optimization. Please wait or terminate current optimization process.   * `planId` - The plan ID. * `ROUTEOPTIMIZATION_EMPTY_VALUE` - A parameter is empty or contains only whitespace.   **Error codes for** `ROUTEOPTIMIZATION_RESTRICTION_EXCEEDED` * `ROUTEOPTIMIZATION_NUMBER_OF_TRANSPORTS_EXCEEDED` - The request contains too many transports.   * `transports` - The number of transports.   * `limit` - The maximum number of transports. * `ROUTEOPTIMIZATION_NUMBER_OF_LOAD_CATEGORIES_EXCEEDED` - The request contains too many load categories.   * `load categories` - The number of load categories   * `limit` - The maximum number of load categories.  **Error codes for** `GENERAL_RESOURCE_NOT_FOUND` * `GENERAL_INVALID_ID` - The ID does not exist.   * `value` - The invalid ID.
	ErrorCode string `json:"errorCode"`
	// The name of the affected query or path parameter or a JSONPath to the affected property of the request.
	Parameter *string `json:"parameter,omitempty"`
	// Additional properties specific to this error class.
	Details map[string]interface{} `json:"details,omitempty"`
}

type _CausingError CausingError

// NewCausingError instantiates a new CausingError object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCausingError(description string, errorCode string) *CausingError {
	this := CausingError{}
	this.Description = description
	this.ErrorCode = errorCode
	return &this
}

// NewCausingErrorWithDefaults instantiates a new CausingError object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCausingErrorWithDefaults() *CausingError {
	this := CausingError{}
	return &this
}

// GetDescription returns the Description field value
func (o *CausingError) GetDescription() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Description
}

// GetDescriptionOk returns a tuple with the Description field value
// and a boolean to check if the value has been set.
func (o *CausingError) GetDescriptionOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Description, true
}

// SetDescription sets field value
func (o *CausingError) SetDescription(v string) {
	o.Description = v
}

// GetErrorCode returns the ErrorCode field value
func (o *CausingError) GetErrorCode() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ErrorCode
}

// GetErrorCodeOk returns a tuple with the ErrorCode field value
// and a boolean to check if the value has been set.
func (o *CausingError) GetErrorCodeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ErrorCode, true
}

// SetErrorCode sets field value
func (o *CausingError) SetErrorCode(v string) {
	o.ErrorCode = v
}

// GetParameter returns the Parameter field value if set, zero value otherwise.
func (o *CausingError) GetParameter() string {
	if o == nil || IsNil(o.Parameter) {
		var ret string
		return ret
	}
	return *o.Parameter
}

// GetParameterOk returns a tuple with the Parameter field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CausingError) GetParameterOk() (*string, bool) {
	if o == nil || IsNil(o.Parameter) {
		return nil, false
	}
	return o.Parameter, true
}

// HasParameter returns a boolean if a field has been set.
func (o *CausingError) HasParameter() bool {
	if o != nil && !IsNil(o.Parameter) {
		return true
	}

	return false
}

// SetParameter gets a reference to the given string and assigns it to the Parameter field.
func (o *CausingError) SetParameter(v string) {
	o.Parameter = &v
}

// GetDetails returns the Details field value if set, zero value otherwise.
func (o *CausingError) GetDetails() map[string]interface{} {
	if o == nil || IsNil(o.Details) {
		var ret map[string]interface{}
		return ret
	}
	return o.Details
}

// GetDetailsOk returns a tuple with the Details field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CausingError) GetDetailsOk() (map[string]interface{}, bool) {
	if o == nil || IsNil(o.Details) {
		return map[string]interface{}{}, false
	}
	return o.Details, true
}

// HasDetails returns a boolean if a field has been set.
func (o *CausingError) HasDetails() bool {
	if o != nil && !IsNil(o.Details) {
		return true
	}

	return false
}

// SetDetails gets a reference to the given map[string]interface{} and assigns it to the Details field.
func (o *CausingError) SetDetails(v map[string]interface{}) {
	o.Details = v
}

func (o CausingError) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CausingError) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["description"] = o.Description
	toSerialize["errorCode"] = o.ErrorCode
	if !IsNil(o.Parameter) {
		toSerialize["parameter"] = o.Parameter
	}
	if !IsNil(o.Details) {
		toSerialize["details"] = o.Details
	}
	return toSerialize, nil
}

func (o *CausingError) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"description",
		"errorCode",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varCausingError := _CausingError{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varCausingError)

	if err != nil {
		return err
	}

	*o = CausingError(varCausingError)

	return err
}

type NullableCausingError struct {
	value *CausingError
	isSet bool
}

func (v NullableCausingError) Get() *CausingError {
	return v.value
}

func (v *NullableCausingError) Set(val *CausingError) {
	v.value = val
	v.isSet = true
}

func (v NullableCausingError) IsSet() bool {
	return v.isSet
}

func (v *NullableCausingError) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCausingError(val *CausingError) *NullableCausingError {
	return &NullableCausingError{value: val, isSet: true}
}

func (v NullableCausingError) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCausingError) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


