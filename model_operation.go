/*
Route Optimization

With the Route Optimization service you can schedule and optimize the routes of your fleet.

API version: 1.11
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package optiflow

import (
	"encoding/json"
	"time"
	"bytes"
	"fmt"
)

// checks if the Operation type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Operation{}

// Operation Information about an operation.
type Operation struct {
	// The name of the operation, possible values: \"optimization\", \"evaluation\".
	Name string `json:"name"`
	Status OperationStatus `json:"status"`
	// The start time of the operation formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339), by means the client can decide to delete the operation. The value is always returned in UTC time.
	StartTime time.Time `json:"startTime"`
	// The elapsed time of the operation [s], by means the client can decide to delete the operation. It represents the duration from the start time until now when the operation is still active or from the start time until the end of operation when this operation is already completed.
	ElapsedTime int32 `json:"elapsedTime"`
	Error *ErrorResponse `json:"error,omitempty"`
}

type _Operation Operation

// NewOperation instantiates a new Operation object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewOperation(name string, status OperationStatus, startTime time.Time, elapsedTime int32) *Operation {
	this := Operation{}
	this.Name = name
	this.Status = status
	this.StartTime = startTime
	this.ElapsedTime = elapsedTime
	return &this
}

// NewOperationWithDefaults instantiates a new Operation object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewOperationWithDefaults() *Operation {
	this := Operation{}
	return &this
}

// GetName returns the Name field value
func (o *Operation) GetName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Name
}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
func (o *Operation) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Name, true
}

// SetName sets field value
func (o *Operation) SetName(v string) {
	o.Name = v
}

// GetStatus returns the Status field value
func (o *Operation) GetStatus() OperationStatus {
	if o == nil {
		var ret OperationStatus
		return ret
	}

	return o.Status
}

// GetStatusOk returns a tuple with the Status field value
// and a boolean to check if the value has been set.
func (o *Operation) GetStatusOk() (*OperationStatus, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Status, true
}

// SetStatus sets field value
func (o *Operation) SetStatus(v OperationStatus) {
	o.Status = v
}

// GetStartTime returns the StartTime field value
func (o *Operation) GetStartTime() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.StartTime
}

// GetStartTimeOk returns a tuple with the StartTime field value
// and a boolean to check if the value has been set.
func (o *Operation) GetStartTimeOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.StartTime, true
}

// SetStartTime sets field value
func (o *Operation) SetStartTime(v time.Time) {
	o.StartTime = v
}

// GetElapsedTime returns the ElapsedTime field value
func (o *Operation) GetElapsedTime() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.ElapsedTime
}

// GetElapsedTimeOk returns a tuple with the ElapsedTime field value
// and a boolean to check if the value has been set.
func (o *Operation) GetElapsedTimeOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ElapsedTime, true
}

// SetElapsedTime sets field value
func (o *Operation) SetElapsedTime(v int32) {
	o.ElapsedTime = v
}

// GetError returns the Error field value if set, zero value otherwise.
func (o *Operation) GetError() ErrorResponse {
	if o == nil || IsNil(o.Error) {
		var ret ErrorResponse
		return ret
	}
	return *o.Error
}

// GetErrorOk returns a tuple with the Error field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Operation) GetErrorOk() (*ErrorResponse, bool) {
	if o == nil || IsNil(o.Error) {
		return nil, false
	}
	return o.Error, true
}

// HasError returns a boolean if a field has been set.
func (o *Operation) HasError() bool {
	if o != nil && !IsNil(o.Error) {
		return true
	}

	return false
}

// SetError gets a reference to the given ErrorResponse and assigns it to the Error field.
func (o *Operation) SetError(v ErrorResponse) {
	o.Error = &v
}

func (o Operation) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Operation) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["name"] = o.Name
	toSerialize["status"] = o.Status
	toSerialize["startTime"] = o.StartTime
	toSerialize["elapsedTime"] = o.ElapsedTime
	if !IsNil(o.Error) {
		toSerialize["error"] = o.Error
	}
	return toSerialize, nil
}

func (o *Operation) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"name",
		"status",
		"startTime",
		"elapsedTime",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varOperation := _Operation{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varOperation)

	if err != nil {
		return err
	}

	*o = Operation(varOperation)

	return err
}

type NullableOperation struct {
	value *Operation
	isSet bool
}

func (v NullableOperation) Get() *Operation {
	return v.value
}

func (v *NullableOperation) Set(val *Operation) {
	v.value = val
	v.isSet = true
}

func (v NullableOperation) IsSet() bool {
	return v.isSet
}

func (v *NullableOperation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOperation(val *Operation) *NullableOperation {
	return &NullableOperation{value: val, isSet: true}
}

func (v NullableOperation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOperation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


